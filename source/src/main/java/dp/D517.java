package dp;

import java.util.Arrays;

/**
 517 超级洗衣机

 假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

 在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n） 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

 给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数。
 如果不能使每台洗衣机中衣物的数量相等，则返回 -1。

  

 示例 1：

 输入: [1,0,5]

 输出: 3

 解释:
 第一步:    1     0 <-- 5    =>    1     1     4
 第二步:    1 <-- 1 <-- 4    =>    2     1     3
 第三步:    2     1 <-- 3    =>    2     2     2
 示例 2：

 输入: [0,3,0]

 输出: 2

 解释:
 第一步:    0 <-- 3     0    =>    1     2     0
 第二步:    1     2 --> 0    =>    1     1     1
 示例 3:

 输入: [0,2,0]

 输出: -1

 解释:
 不可能让所有三个洗衣机同时剩下相同数量的衣物。
  

 提示：

 n 的范围是 [1, 10000]。
 在每台超级洗衣机中，衣物数量的范围是 [0, 1e5]。

 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/super-washing-machines
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class D517 {

    public static void main(String[] args) {
        new D517().findMinMoves(new int[] {0, 0, 6});
    }

//    思路：首先，显然只有当 N 台洗衣机的衣服数量之和 D 是 N 的倍数时，才能使得每台洗衣机最终的衣服数量相等。
//    当计算出 D 之后，我们可以通过 D / N 得到每台洗衣机最终的衣服数量。为了方便计算，
//  我们可以将所有的 N 个数分别减去 D / N，这样若第 i 台洗衣机对应的数为正数，说明它需要拿出衣服分给别的洗衣机；

//  若第 i 台洗衣机对应的数为负数，说明它需要从别的洗衣机得到衣服。由于每一步操作中一台洗衣机只能给出一件衣服，
//  因此如果其中一台洗衣机对应的数为正数 x，那么操作步数至少为 x。并且对于前 i 台洗衣机，它们对应的数的和若为 y，
//  那么它们需要和后 N - i 台洗衣机至少传递 |y| 次衣服，每次只能传递一件（若 y 为正数，则前者将衣服传递给后者；
//  若 y 为负数，则后者将衣服传递给前者），操作步数至少为 y。因此，最少的操作步数为“数组元素的最大值”和“数组元
//  素前缀和的绝对值的最大值”中的较大值。
    public int findMinMoves(int[] machines) {
        int len = machines.length;
        int sum = Arrays.stream(machines).sum();
        // 只有当衣服的总数量能被洗衣机数量整除的时候，才能进行分配
        if (sum % len > 0) return -1;

        int target = sum / len, step = 0;
        sum = 0;
        for (int i = 0; i < len; i++) {
            sum += target - machines[i];
            step = Math.max(step, Math.max(Math.abs(sum), machines[i] - target));
        }
        return step;
    }
}
